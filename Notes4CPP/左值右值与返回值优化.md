https://cloud.tencent.com/developer/article/2352089
https://zhuanlan.zhihu.com/p/335994370
https://zhuanlan.zhihu.com/p/374392832


int a = 10;
int* tmp = &a;
int& tmp = a;  // 完全等价




常见的左值
1、变量(对象)；
2、const 变量(对象)；
3、对指针解引用，*(指针)；
4、数组元素，a[1]；
5、结构体成员、类成员，s.m_a、ps->ma； 


常见的右值
1、函数的非引用返回值。这种返回值位于临时内存单元中，运行到下一条语句时，它们可能不再存在；
2、字面常量（立即数），引号括起的字符串除外(它们有其地址表示)，42、'a'；
3、算术运算符(+、-、*、/、%、正号、负号)的求值结果，1+2；
4、逻辑运算符(&&、||、!)的求值结果，a!=10；
5、关系运算符(>、>=、<、<=、==、!=)的求值结果，a>10 && a<100；
6、当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值。


函数的返回值有几种返回方式：
* 通过寄存器返回：没有内存地址，所以是prvalue。比如返回一个int。
* 返回值转出参：如果返回值时平凡类型，调用方直接传递一个内存地址到被调用方，被调用方将返回值直接放到这个内存地址中。调用过程结束之后，这个内存地址存放的就是被调用方的返回值。
* 通过拷贝构造函数返回：如果返回的类型是非平凡的，那么函数返回时，会先生成一个临时的局部变量，然后通过拷贝构造函数来构造返回值，再析构这个局部变量。

注：平凡类型指的是：构造函数、拷贝函数、移动构造函数、拷贝赋值运算符、移动赋值运算符、析构函数都是平凡的（编译器默认生成的，用户没有自定义的）

调用方接收返回值时，如果调用函数只需要被调用函数返回值的一部分
```c++
class Book
{
public:
    long a,b,c,d,e,f;
    Book():a(100),b(100),c(100){}
};
Book test1()
{
    return Book();
}

int main()
{
    int a = test1().a;

    return 0;
}
```
会默认在调用函数的位置生成一个匿名的临时变量，然后对这个匿名临时变量做操作
```c++
int main()
{
    Book tmp = test1();
    int a = tmp.a;
    // tmp.~Book(); 如果是非平凡的，在给a赋值后会立即调用这个临时变量的析构函数。
}
```

简单总结一下，函数返回数据的3种处理方式：
* 直接存在寄存器里：对应于返回一个很小的变量，比如返回一个int。
* 直接操作用于接收返回值的变量（如果是平凡的，直接操作；如果是非平凡的，先创建好一个局部变量，然后再拷贝过来）：对应于返回一个类，且调用方用一个类接收
* 先放在一个临时的内存空间中，使用完后再析构掉：对应于返回一个类，且调用方只接收这个类的一部分。

<!-- 
在编译器实现的时候，根据返回值的大小，决定它放到寄存器里还是内存里，放寄存器里的就是 prvalue，放内存里的就是 xvalue
```c++
class Book
{
    public:
    long a,b,c,d,e,f;
    Book():a(100),b(100),c(100){}
};
Book test1()
{
    return Book();
}
``` -->






**返回值优化需要总结一下TODO**


**返回一个int，返回一个平凡类全部接收、返回一个平凡类部分接收、返回一个非平凡类全部接收、返回一个非平凡类部分接收**
**太复杂了，还需要考虑返回一个引用、右值引用，考虑返回值优化。。。**