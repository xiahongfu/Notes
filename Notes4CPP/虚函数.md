# 为什么子类继承父类的虚函数访问权限不能更严格？
在子类中重写虚函数时，其访问权限不能更严格（即不能由 public 变为 private 或 protected），否则编译器会报错。

主要原因是会导致运行时错误，因为权限检查是编译期行为，运行时不会进行权限检查。当通过基类指针调用时，编译器无法在编译期检查实际的子类访问权限。会导致运行时错误。所以干脆直接规定子类重写虚函数时，其访问权限不能更严格。


# 纯虚函数和抽象类
纯虚函数就是没有实现的虚函数。子类必须实现纯虚函数。抽象类是包含纯虚函数的类。抽象类无法被实例化，只能被继承。纯虚函数定义方式：`virtual double getArea() = 0;`



# 静态绑定和动态绑定

* 静态绑定指的是编译阶段就能确定要调用哪个方法；动态绑定指的是在运行时才能确定要调用哪个方法。
* 在以下的例子中，由于Shape的draw没有viretual修饰，所以会输出"Drawing a shape."。如果Shape的draw有virtual修饰，那么就会输出"Drawing a circle."。
```C++ 
class Shape {
public:
    void draw() { cout << "Drawing a shape." << endl; }
};

class Circle : public Shape {
public:
    void draw() { cout << "Drawing a circle." << endl; }
};

int main() {
    Shape* shapeObj = new Circle();
    shapeObj->draw(); // 编译时期确定方法调用，输出 "Drawing a shape."
}
```


# 析构函数是虚函数的必要性
显而易见，如果析构函数不是虚函数的话，那么只会调用父类的析构，不会调用子类的析构。


# 哪些函数不能被声明为虚函数
构造函数、友元函数、非类成员函数
**内联函数**：inline函数只是对编译器的一个建议。如果给inline函数加了virtual关键字会导致inline失效。虚函数和内联函数天然存在冲突，一个是在编译期就内联到调用者的位置，一个是在运行时才能确定到底调用了哪个函数。
**静态成员函数**： 静态成员函数归类所有，与类的实例化对象无关。虚函数需要通过this指针访问vptr指针，通过vptr指针访问vtable，而静态成员函数连this指针都没有，因此static函数无法声明为虚函数。static和virtual同时使用会产生编译期错误。