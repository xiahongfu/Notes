
# C++类

https://blog.csdn.net/JMW1407/article/details/108785842

## 构造函数

不管是什么构造函数，构造一个对象时都需要为这个对象生成一定的内存空间。所有的构造函数都需要按一定的规则初始化这个内存空间。如果对象A中包含对象B，那么在构造对象A的时候一定会调用B对象的默认构造函数。
常量成员变量、引用类型成员变量、没有默认构造函数的成员变量 必须在构造函数的初始化列表中初始化。
构造函数执行顺序：
* 虚拟基类的构造函数
* 非虚拟基类的构造函数
* 成员对象构造函数
* 本类构造函数

## 编译器默认生成的函数

2~6涉及资源的管理，
1. 默认构造函数：用于无参创建对象。若类中有必须在构造函数的参数化列表中进行初始化的成员，则不会生成无参构造函数。
2. 默认拷贝构造函数：用同类型对象初始化新对象。默认生成的拷贝构造函数是浅拷贝。`Test(const Test& test)=default;`
3. 默认析构函数：作用是做一些清理工作，析构函数的执行过程和构造函数完全相反。
4. 默认重载赋值运算符函数：默认的赋值运算符函数是浅拷贝。`Test& operator=(const Test& test)=default;`
5. 默认移动构造函数：`Test(Test &&)=default;`
6. 默认重载移动赋值操作符函数：`Test& operator=(Test &&)=default;`
7. 默认重载取地址运算符函数：取地址用的，存在感不强。`Test* operator &();`

## 三法则、五法则、零法则

* **三法则**：在一个类中，如果“析构函数、拷贝构造函数、拷贝赋值函数”这三个函数其中任意一个需要显式地定义，那么必须同时显式地定义所有的这三个函数。
* **五法则**：如果用户定义了三法则的三个函数，那么“移动构造函数、移动赋值函数”这两个函数会被隐式地标记为delete。这通常不会导致错误，而是会失去优化机会。所以五法则要求：如果这五个函数有任意一个被标记为=delete或被定义，那么应当对这所有的五个函数全部标记为=delete或定义。
* **零法则**：以上的五个函数，需要在一个专门的类中处理所有权。一个类不应该即处理业务逻辑，又自定义以上的五个函数中的任何一个。零法则强调遵循单一职责原则。

## 六大默认函数的调用时机

**拷贝构造函数**
什么时候会调用拷贝构造函数