# 构造函数

不管是什么构造函数，构造一个对象时都需要为这个对象生成一定的内存空间。所有的构造函数都需要按一定的规则初始化这个内存空间。如果对象A中包含对象B，那么在构造对象A的时候一定会调用B对象的默认构造函数。
常量成员变量、引用类型成员变量、没有默认构造函数的成员变量 必须在构造函数的初始化列表中初始化。
构造函数执行顺序：
* 虚拟基类的构造函数
* 非虚拟基类的构造函数
* 成员对象构造函数：使用列表初始化时会按成员变量在类中声明顺序；不使用列表初始化，则会根据代码执行顺序。
* 本类构造函数

# 编译器默认生成的函数

2~6涉及资源的管理，
1. 默认构造函数：用于无参创建对象。若类中有必须在构造函数的参数化列表中进行初始化的成员，则不会生成无参构造函数。
2. 默认拷贝构造函数：用同类型对象初始化新对象。默认生成的拷贝构造函数是浅拷贝。`T(const T& a)=default;`
3. 默认移动构造函数：`T(T &&)=default;`
4. 默认重载拷贝赋值运算符函数：默认的赋值运算符函数是浅拷贝。`T& operator=(const T& a)=default;`
5. 默认重载移动赋值运算符函数：`T& operator=(T &&)=default;`
6. 默认重载取地址运算符函数：取地址用的，存在感不强。`T* operator &();`
7. 默认析构函数：作用是做一些清理工作，析构函数的执行过程和构造函数完全相反。

## 默认函数不生成条件

拷贝/移动构造，拷贝/移动赋值以及析构函数，用户自定义了任意一个以上函数，那么其他函数将不会自动生成。
默认构造函数：用户自定义了任何构造函数；有必须在初始化列表中初始化的成员。


## 三法则、五法则、零法则

* **三法则**：在一个类中，如果“析构函数、拷贝构造函数、拷贝赋值函数”这三个函数其中任意一个需要显式地定义，那么必须同时显式地定义所有的这三个函数。
* **五法则**：五法则是三法则的拓展，c++11后引入了移动语义，三法则扩展为五法则。五法则要求：如果这五个函数有任意一个被标记为=delete或被定义，那么应当对这所有的五个函数全部标记为=delete或定义。
* **零法则**：以上的五个函数，需要在一个专门的类中处理所有权。一个类不应该即处理业务逻辑，又自定义以上的五个函数中的任何一个。零法则强调遵循单一职责原则。比如实际案例中，Buffer类处理data的生命周期。DataProcessor类持有Buffer类，不需要关心Buffer的生命周期。

# 拷贝/移动构造、拷贝/移动赋值

## 拷贝构造函数

**拷贝构造函数长啥样**
假设类为T，第一个参数是`T&` `const T&` `volatile T&` `const volatile T&` 且 要么没有其他参数，要么其它参数都有默认实参，如下面都是拷贝构造函数：
```c++
T(T& t);
T(const T& t);
T(const T& t, int a=0, int b=0);
T(volatile T& t);
T(const volatile T& t);
```

**拷贝构造函数什么时候调用**
* 对象作为参数按值传递：`void Test(T a);`
* 对象作为函数返回值按值返回：`T Test() { return T();}` C++17后RVO是强制必须进行的，NRVO不强制但是大多数编译器都支持。
* 使用一个对象初始化另一个新对象：`T b = a;`  `T b(a);` `T b = T();`
* 用花括号列表初始化数组元素或聚合对象时：`T arr[] = {T(), T()};` `T arr[] = {a, b};`

> **拷贝省略（Copy elision）**：当使用临时对象初始化一个新对象时，可能会触发拷贝省略。考虑这句代码：`T b = T();`。理论上会执行一次构造函数，一次拷贝构造函数，两次析构函数。但是经过拷贝省略优化后，编译器直接在Base2的地址调用构造函数，只会执行一次构造函数和一次析构函数。
> 
> **返回值优化**：返回值优化（RVO）是一种编译期优化技术，用于消除不必要的拷贝以提升程序性能。当函数返回一个对象时，理论上会在函数内部创建局部对象，然后将这个局部对象拷贝/移动到该函数外部调用的位置，然后销毁内部的局部对象。返回值优化指的是直接在函数外部的目标位置构造对象，从而省去一次拷贝/移动。NRVO是具名返回值优化，返回的是一个有名字的局部变量。
>
> **RVO失效的情况**：返回函数参数 or 函数有多个不同的返回值

```c++
T Test(T a) { // 参数按值传递会调用一次拷贝构造
    T ret = a; // 用一个对象初始化另一个对象会调用拷贝构造
    return ret; // 按值返回。会调用一次拷贝构造，但是会被RVO优化掉。
}
```

## 移动构造函数

移动构造函数通常不应该抛出异常，因为移动构造函数不申请任何资源，所以移动构造函数建议使用`noexcept`。

**移动构造函数长啥样**
移动构造函数的输入接收一个**右值**。移动构造函数的形式和拷贝构造函数类似，只不过`T&`换成了`T&&`
> **右值**：函数返回的临时对象、T()创建的匿名对象，或被std::move()转换的左值。
> **std::move()**：仅做类型转换，用于将左值转换为右值。具体如何移动资源仍然要看**移动构造函数**和**移动赋值函数**

**移动构造函数什么时候调用**
* 用右值初始化对象：`T b=Test();` `T b=T();` `T b = move(a);`。前两种在C++17中会强制进行拷贝省略优化所以不执行移动构造函数。后一种会执行移动构造函数。
* 函数返回局部对象且无法进行RVO时
```c++
T Test(bool flag)
{
    T a, b;
    if (flag) return a;
    return b;
}
```
* 函数参数接收左值，但是调用方传递右值：`void Test(T b);    Test(std::move(a));` 这里传递了一个右值，但是需要一个左值，所以会触发`T(T&&)`移动构造函数

## 拷贝赋值函数

**拷贝赋值函数长啥样**
返回值：实践中基本都返回`T&`类型
参数：只能有一个入参，类型是**T&** **const T&** **volatile T&** **const volatile T&**

**拷贝赋值运算符**

* 用一个左值给一个对象赋值
* 移动赋值可不用时，右值赋值会退化wield拷贝赋值
* 函数返回值赋值给已存在对象且RVO失效时


## 移动赋值函数 

**移动赋值函数长啥样**

返回值：实践中基本都返回`T&`类型
参数：只能有一个入参，类型是**T&&** **const T&&** **volatile T&&** **const volatile T&&**

**移动赋值函数什么时候调用**

用一个右值给一个对象赋值时

```c++
T obj, robj;
obj = T();
obj = std::move(robj);
```