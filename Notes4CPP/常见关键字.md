# const

[C/C++ 基础中的基础： const 修饰符用法总结！](https://zhuanlan.zhihu.com/p/90720012)

> 首先，来看看const的基本含义。在 C/C++ 语言中，const关键字是一种修饰符。所谓“修饰符”，就是在编译器进行编译的过程中，给编译器一些“要求”或“提示”，但修饰符本身，并不产生任何实际代码。就 const 修饰符而言，它用来告诉编译器，被修饰的这些东西，具有“只读”的特点。在编译的过程中，一旦我们的代码试图去改变这些东西，编译器就应该给出错误提示。
> 
>所以，const修饰符的作用主要是利用编译器帮助我们检查自己代码的正确性。我们使用const在源码中标示出“不应该改变”的地方，然后利用编译器，帮助我们检查这些地方是否真的没有被改变过。如果我们不小心去修改了这些地方，编译器就会报错，从而帮助我们纠正错误。使用const和不使用const，对于最终编译产生的代码并没有影响。

const的主要作用是进行编译期检查，用于在**编译阶段提供约束**。const修饰的变量/对象表明该对象/变量不应该被修改，如果代码中不小心修改了这些不应该被修改的对象/变量，编译器可以帮我们检查出来，从而减少逻辑错误。const理论上不会对编译生成的代码产生任何影响。（非const全局变量通常存储在数据段，而const全局/静态变量会被存储到只读数据段，运行时如果尝试修改会触发内存访问错误。）

## 修饰指针、引用

常量指针和指针常量: const后边的内容为常量。
```c++
const int  ptr = 5;     // ptr为常量，初始化后不可更改，错误如：ptr = 6
const int* ptr = &a;    //*ptr为常量，不能通过*ptr改变它指向的内容，错误如：*ptr = 5
int const* ptr;         //*ptr为常量，同上
int* const ptr = &a;    // ptr为常量，初始化后不能再指向其它地址，错误如：ptr = &b
```

引用本质上是指针常量，int& 本质上是 int* const。因此 const int& 本质上是 const int* const。因此常引用即不能改变指向的地址，也不能改变指向的内容。


## 修饰函数参数

const 作为函数参数，有一种特殊情况。当入参为非const指针时，传入一个const指针就会产生编译报错。原因是`const int* `修饰的不是指针，而是指针所指向的对象。通过值传递的方式传递指针时会产生一个新的指针，指向同一个数据，如果新指针没有const修饰，那么就有可能修改指针指向的数据，此时就会产生逻辑错误。
> 隐式转换：当传递的参数类型与函数参数类型不匹配时，会出现隐式转换。比如`int`转`double`。下面例子中传递的参数类型为`const int*`，实际参数类型为`int*`，类型不匹配，因此需要进行隐式类型转换，尝试将`const int*`转换为`int*`，但是这种转换会导致**权限放大**（从"只读"变成"读写"），违反了`const`的语义约束，因此C++标准明确规定禁止这种转换。
```c++
void func(int* notConstInt){}
void main(int argc, char* argv[])
{
    const int* p = new int(0);
    func(p);   // 编译错误：Cannot convert const int* to parameter type int*
}
```

## 修饰返回值

**const int**
返回值不是指针和引用类型时，无需添加const修饰符，添加了也没有用。因为返回值是原数据的一份临时拷贝，const标记这份临时拷贝不可被修改，这个拷贝在函数调用方需要接收后再使用。

**const int&**
返回值是常引用时，分为以下三种情况
* int接收：会拷贝值
* int&接收：非法，用int&接收代表不会拷贝值。接收的变量与返回值类型不匹配，不能用非const引用接收（权限放大）
* const int&接收：合法
```c++
int x = 10;
const int& func() {
    return x;  // 这里不能返回局部变量，会产生未定义行为
}

int main() {
    // 合法：用 const 引用接收
    const int& ref = func();  
    // 合法：用普通变量接收（会拷贝值，脱离 const 限制）
    int a = func();  
    // 非法：不能用非 const 引用接收（权限放大）
    int& ref2 = func();  // 编译错误
    return 0;
}
```

**const int***
当返回值是常指针时，返回的也是原指针的一份临时拷贝，和原指针指向同一个地址。const标记这个临时拷贝的类型是一个常量指针，所以必须用`const int*`去接收（或直接当成一个`const int*`去用也可以）

```C++
int p=0;
const int* test()
{
    int* ptr = &p;
    return ptr;
}

void main(int argc, char* argv[])
{
    const int* remove_reference0 = test(); // 合法
    int* remove_reference1 = test();  // 非法：Cannot initialize local variable 'var1' of type int* with const int*
    const int& remove_reference2 = *test(); // 合法
    int& remove_reference3 = *test(); // 非法：Non-const lvalue reference 'var3' to type int cannot bind to lvalue of type const int
}
```

## 修饰成员函数和类的实例变量

* **修饰成员函数**：const修饰类的成员函数表示该函数不能修改任何非const成员变量（除非成员变量被mutable修饰符修饰）
* **修饰类的实例变量**：const修饰类的实例变量表示该实例中的任何数据均不允许改变，且不能调用任何非const成员函数。

# typedef

**typedef定义的是一个完整的类型别名**，而非简单的文本替换。
下面的案例表明cTree变量本身是const的。如果是`const TreeNode* cTree`，那么*cTree是const的。
```c++
typedef TreeNode* Tree;
TreeNode a, b;
const Tree cTree = &a;
*cTree = b;   // 合法，Tree是一个完整的类型，cTree不可变但是cTree指针指向的内容可变。
// cTree = &b;   // 非法
```